#pragma once

#include <fstream>
#include <utility>
#include <vector>

#include "log.hpp"
#include "timers.hpp"
#include "version.h"

#ifndef UPCXX_UTILS_NO_THREADS
#include <thread>
#endif

#ifndef UPCXX_UTILS_LOG_FLUSH_INTERVAL_MS
#define UPCXX_UTILS_LOG_FLUSH_INTERVAL_MS 60000.
#endif

#ifndef UPCXX_UTILS_SAMPLE_INTERVAL_MS
#define UPCXX_UTILS_SAMPLE_INTERVAL_MS 500
#endif

#include <upcxx/upcxx.hpp>

namespace upcxx_utils {

extern ofstream _memlog;
void open_memlog(string name);
void close_memlog();

std::pair<double, std::string> get_free_mem(const std::vector<std::string> &);
double get_free_mem(bool local_barrier = false);
double &__max_free_mem_per_rank();
double get_max_free_mem_per_rank();
string get_self_stat(void);

#define _TRACK_MEMORY(free_mem, self_stat) " Free memory: ", ::upcxx_utils::get_size_str(free_mem), ", stat: ", self_stat

#define LOG_MEM_OS(os, label)                                             \
  ::upcxx_utils::logger(os, false, false, true, LOG_LINE_TS_LABEL, label, \
                        _TRACK_MEMORY(::upcxx_utils::get_free_mem(), ::upcxx_utils::get_self_stat()))

#define LOG_MEM(label)                                                                                             \
  do {                                                                                                             \
    std::string __label(label);                                                                                    \
    if (::upcxx_utils::_memlog.is_open()) {                                                                        \
      LOG_MEM_OS(::upcxx_utils::_memlog, __label);                                                                 \
      ::upcxx_utils::_memlog.flush();                                                                              \
    } else if (::upcxx_utils::_dbgstream.is_open()) {                                                              \
      LOG_MEM_OS(::upcxx_utils::_dbgstream, __label);                                                              \
    } else if (::upcxx_utils::_logstream.is_open()) {                                                              \
      LOG_MEM_OS(::upcxx_utils::_logstream, __label);                                                              \
    }                                                                                                              \
    upcxx::barrier(upcxx::local_team());                                                                           \
    auto fut_free_mem = upcxx_utils::min_sum_max_reduce_one(::upcxx_utils::get_free_mem() / ONE_GB);               \
    upcxx::barrier(upcxx::local_team());                                                                           \
    upcxx::future<> __fut_log_mem =                                                                                \
        upcxx::when_all(Timings::get_pending(), fut_free_mem).then([__label](upcxx_utils::MinSumMax<double> msm) { \
          SLOG_VERBOSE(__label, " free_mem GB: ", msm.to_string(), "\n");                                          \
        });                                                                                                        \
    Timings::set_pending(__fut_log_mem);                                                                           \
  } while (0)

/*
 Generated by ChatGPT by the command  write a templated class in C++ for the streaming the approximate moving average and moving
 standard deviation when the update function is called.  Implement it efficiently for the entire sequence no mater the length and do
 not store any of the data stream

 Modified by Rob 2/17/2023 to remove template, put methods in .cpp and add min/max/count ops

 */
class MovingAverageStdDev {
  /* This implementation uses Welford's algorithm to update the mean and variance in a single pass,
  without storing any of the data stream. The Update function is called to add a new data point, and
  the Mean, Variance, and StdDev functions return the approximate moving average and moving standard
  deviation, based on the entire sequence seen so far.
  */
 public:
  MovingAverageStdDev()
      : n_(0)
      , mean_(0)
      , m2_(0)
      , max_(0)
      , min_(0) {}

  void Update(const double &x);

  double Mean() const { return mean_; }

  double Variance() const;

  double StdDev() const;

  double Min() const { return min_; }

  double Max() const { return max_; }

  size_t Count() const { return n_; }

 private:
  size_t n_;
  double mean_;
  double m2_;
  double min_, max_;
};

class TrackActivity {
  // Simple class to call periodically tracking outlier periods of inactivity
 public:
  timepoint_t last_check;
  MovingAverageStdDev stats;
  using timepoints = std::pair<timepoint_t, timepoint_t>;
  std::vector<timepoints> outliers;
  timepoints max_timepoints;

  TrackActivity();

  void reset();

  double get_time_since_last_check(timepoint_t t = upcxx_utils::BaseTimer::now()) const;

  bool check(bool record = true);

  size_t get_count() const;

  double get_avg() const;

  double get_stddev() const;

  double get_max() const;

  double get_min() const;

  timepoints get_max_times() const;

  std::vector<timepoints> &get_outliers();
};

class MemoryTrackerThread {
#ifdef UPCXX_UTILS_NO_THREADS
  void *t = nullptr;
#else
  std::thread *t = nullptr;
#endif
  double start_free_mem, min_free_mem;
  long ticks, sample_ms;
  bool fin, opened;
  std::string tracker_filename;
  using Activities = std::vector<TrackActivity>;
  using DistActivities = upcxx::dist_object<Activities>;
  DistActivities dist_activities;

 public:
  MemoryTrackerThread(string _tracker_filename = "")
      : t{}
      , ticks{0}
      , sample_ms{UPCXX_UTILS_SAMPLE_INTERVAL_MS}
      , fin{false}
      , opened{false}
      , tracker_filename(_tracker_filename)
      , dist_activities(upcxx::world()) {}
  MemoryTrackerThread(const MemoryTrackerThread &) = delete;  // no copy
  MemoryTrackerThread(MemoryTrackerThread &&) = default;
  void start();
  void stop();

  void send_activity_check();
};

};  // namespace upcxx_utils
